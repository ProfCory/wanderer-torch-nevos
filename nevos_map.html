<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nevos Custom Grid Map — v2</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    #app { display: grid; grid-template-columns: 320px 1fr; height: 100%; }
    aside { border-right: 1px solid #ddd; padding: 12px; overflow: auto; }
    aside h1 { font-size: 16px; margin: 0 0 8px; }
    aside .controls { display: grid; gap: 8px; margin-bottom: 12px; }
    aside input[type="text"], aside select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }
    aside button, .btn { padding: 8px 10px; border: 1px solid #bbb; background: #f6f6f6; border-radius: 6px; cursor: pointer; }
    aside .row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .small { font-size: 12px; color: #555; }
    #map { width: 100%; height: 100%; }

    /* Grid label styling */
    .grid-col-label, .grid-row-label {
      background: rgba(255,255,255,0.8);
      padding: 2px 4px; border-radius: 4px; font-size: 12px; color: #333;
    }
    .leaflet-tooltip.grid-tip { background: rgba(255,255,255,0.9); border: 1px solid #ccc; color:#222; }
  </style>
</head>
<body>
  <div id="app">
    <aside>
      <h1>Nevos Grid Map — v2</h1>
      <div class="controls">
        <div class="row">
          <label><input type="checkbox" id="toggleGrid" checked> Show world grid</label>
          <label><input type="checkbox" id="zoomCellMode"> Click-to-zoom into cell</label>
        </div>
        <div class="row">
          <label>World rows (letters)
            <input type="number" id="rowsInput" min="2" max="52" value="10">
          </label>
          <label>World cols (numbers)
            <input type="number" id="colsInput" min="2" max="52" value="10">
          </label>
        </div>
        <div class="row">
          <label>Subgrid rows
            <input type="number" id="subRowsInput" min="2" max="52" value="10">
          </label>
          <label>Subgrid cols
            <input type="number" id="subColsInput" min="2" max="52" value="10">
          </label>
        </div>
        <div class="row">
          <button id="resetView">Back to world</button>
          <button id="redrawBtn">Redraw grid</button>
        </div>
        <div class="small">Image file must be next to this HTML:</div>
        <code>IMAGE_URL = 'Nevos_main.png' (1024×1024)</code>
      </div>
      <div class="small">Tip: Toggle <em>Click-to-zoom into cell</em> to drill down. World grid letters A.. and numbers 1.. are rendered at the map edges.</div>
    </aside>
    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    // --- CONFIG ---
    const IMAGE_URL = 'Nevos_main.png'; // your uploaded map image
    const IMAGE_W = 1024;               // px
    const IMAGE_H = 1024;               // px

    // DOM refs
    const rowsInput = () => parseInt(document.getElementById('rowsInput').value, 10);
    const colsInput = () => parseInt(document.getElementById('colsInput').value, 10);
    const subRowsInput = () => parseInt(document.getElementById('subRowsInput').value, 10);
    const subColsInput = () => parseInt(document.getElementById('subColsInput').value, 10);

    // --- MAP INIT ---
    const bounds = [[0,0], [IMAGE_H, IMAGE_W]]; // y,x in CRS.Simple
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -2, maxZoom: 4, preferCanvas: true });
    L.imageOverlay(IMAGE_URL, bounds).addTo(map);
    map.fitBounds(bounds);

    // Layers
    const worldGridLayer = L.layerGroup().addTo(map);
    const worldLabelLayer = L.layerGroup().addTo(map);
    let subgridLayer = null; // created when drilling into a cell
    let subgridLabelLayer = null;

    // --- GRID HELPERS ---
    function lineLatLngsForVertical(x){ return [[0, x], [IMAGE_H, x]]; }
    function lineLatLngsForHorizontal(y){ return [[y, 0], [y, IMAGE_W]]; }

    function drawWorldGrid(R, C){
      worldGridLayer.clearLayers();
      worldLabelLayer.clearLayers();
      const cellW = IMAGE_W / C, cellH = IMAGE_H / R;
      // lines
      for (let c=0; c<=C; c++) L.polyline(lineLatLngsForVertical(c*cellW), {color:'#000', weight:1, opacity:0.25}).addTo(worldGridLayer);
      for (let r=0; r<=R; r++) L.polyline(lineLatLngsForHorizontal(r*cellH), {color:'#000', weight:1, opacity:0.25}).addTo(worldGridLayer);
      // labels (columns top, rows left)
      for (let c=0; c<C; c++) {
        const xMid = (c+0.5)*cellW;
        L.marker([0 + 6, xMid], {interactive:false, icon: L.divIcon({className:'grid-col-label', html: String(c+1)})}).addTo(worldLabelLayer);
      }
      for (let r=0; r<R; r++) {
        const yMid = (r+0.5)*cellH;
        L.marker([yMid, 0 + 6], {interactive:false, icon: L.divIcon({className:'grid-row-label', html: String.fromCharCode(65+r)})}).addTo(worldLabelLayer);
      }
    }

    function gridRefFromLatLng(latlng, R, C){
      const cellW = IMAGE_W / C, cellH = IMAGE_H / R;
      const col = Math.min(C-1, Math.max(0, Math.floor(latlng.lng / cellW)));
      const row = Math.min(R-1, Math.max(0, Math.floor(latlng.lat / cellH)));
      return { row, col, label: `${String.fromCharCode(65+row)}-${col+1}`, cellBounds: [[row*cellH, col*cellW],[ (row+1)*cellH, (col+1)*cellW ]] };
    }

    // initial draw
    drawWorldGrid(rowsInput(), colsInput());

    // --- TOGGLES ---
    document.getElementById('toggleGrid').addEventListener('change', (e)=>{
      if (e.target.checked){
        map.addLayer(worldGridLayer); map.addLayer(worldLabelLayer);
      } else {
        map.removeLayer(worldGridLayer); map.removeLayer(worldLabelLayer);
      }
    });
    document.getElementById('redrawBtn').addEventListener('click', ()=>{
      drawWorldGrid(rowsInput(), colsInput());
    });
    document.getElementById('resetView').addEventListener('click', ()=>{
      map.fitBounds(bounds);
      if (subgridLayer) { map.removeLayer(subgridLayer); subgridLayer = null; }
      if (subgridLabelLayer) { map.removeLayer(subgridLabelLayer); subgridLabelLayer = null; }
    });

    // --- SUBGRID (drill‑down) ---
    let zoomCellMode = false;
    document.getElementById('zoomCellMode').addEventListener('change', (e)=>{ zoomCellMode = e.target.checked; });

    function enterSubgrid(cell){
      // remove existing subgrid
      if (subgridLayer) { map.removeLayer(subgridLayer); subgridLayer = null; }
      if (subgridLabelLayer) { map.removeLayer(subgridLabelLayer); subgridLabelLayer = null; }
      const R = subRowsInput(), C = subColsInput();
      const [[y0,x0],[y1,x1]] = cell.cellBounds;
      // Fit to the clicked cell
      map.fitBounds(cell.cellBounds);
      // Build subgrid within that cell rectangle
      subgridLayer = L.layerGroup().addTo(map);
      subgridLabelLayer = L.layerGroup().addTo(map);
      const width = x1 - x0, height = y1 - y0;
      const cellW = width / C, cellH = height / R;
      // Lines
      for (let c=0; c<=C; c++) L.polyline([[y0, x0 + c*cellW], [y1, x0 + c*cellW]], {color:'#006', weight:1, opacity:0.35}).addTo(subgridLayer);
      for (let r=0; r<=R; r++) L.polyline([[y0 + r*cellH, x0], [y0 + r*cellH, x1]], {color:'#006', weight:1, opacity:0.35}).addTo(subgridLayer);
      // Labels (A..,1.. inside the cell edges)
      for (let c=0; c<C; c++) {
        const xMid = x0 + (c+0.5)*cellW;
        L.marker([y0 + 6, xMid], {interactive:false, icon: L.divIcon({className:'grid-col-label', html: String(c+1)})}).addTo(subgridLabelLayer);
      }
      for (let r=0; r<R; r++) {
        const yMid = y0 + (r+0.5)*cellH;
        L.marker([yMid, x0 + 6], {interactive:false, icon: L.divIcon({className:'grid-row-label', html: String.fromCharCode(65+r)})}).addTo(subgridLabelLayer);
      }
    }

    // Click handler: either drill into cell or just tooltip info
    map.on('click', (e)=>{
      const world = gridRefFromLatLng(e.latlng, rowsInput(), colsInput());
      if (zoomCellMode) {
        enterSubgrid(world);
      } else {
        L.tooltip({ permanent:false, direction:'top', className:'grid-tip' })
          .setLatLng(e.latlng)
          .setContent(`World cell <strong>${world.label}</strong>`)
          .addTo(map);
      }
    });
  </script>
</body>
</html>
